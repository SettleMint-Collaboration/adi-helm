# ADI Stack Helm Chart Values
# https://github.com/ADI-Foundation-Labs/ADI-Stack-EN-Setup-script
#
# =============================================================================
# MULTI-CLOUD PERFORMANCE GUIDE
# =============================================================================
#
# This chart supports AWS EKS, Google GKE, and Azure AKS with optimized
# configurations for blockchain node workloads (high IOPS requirements).
#
# PERFORMANCE TIERS (for storage-intensive blockchain nodes):
# -----------------------------------------------------------
# | Tier   | IOPS     | Throughput | Use Case              |
# |--------|----------|------------|------------------------|
# | Low    | 3,000    | 125 MB/s   | Development/Testing    |
# | Medium | 16,000   | 500 MB/s   | Testnet nodes          |
# | High   | 64,000+  | 1,000 MB/s | Production mainnet     |
#
# STORAGE CLASS QUICK REFERENCE:
# ------------------------------
# AWS:   gp3 (low) | gp3+provisioned (medium) | io2 (high)
# GKE:   standard-rwo (low) | premium-rwo (medium) | hyperdisk-extreme (high)
# Azure: managed-csi (low) | managed-csi-premium (medium) | managed-csi-premium-v2 (high)
#
# See individual sections below for detailed cloud-specific configurations.
# =============================================================================

# -- Global settings
global:
  # -- Image registry to use for all images
  imageRegistry: ""
  # -- Image pull secrets for all pods
  imagePullSecrets: []

# -- Image pull secrets (can also use global.imagePullSecrets)
imagePullSecrets: []
  # - harbor-registry

# -- Override chart name
nameOverride: ""
# -- Override full name
fullnameOverride: ""

# -- Genesis configuration for the blockchain
genesis:
  # -- Bridgehub contract address
  bridgehubAddress: "0xFd3cE61C65dDd1039e6e9e07FB6D6e16388d1cc7"
  # -- Chain ID
  chainId: "99999"
  # -- Main node RPC URL
  mainNodeRpcUrl: "https://rpc.adifoundation.ai"

# -- L1 RPC configuration
l1Rpc:
  # -- L1 RPC URL (REQUIRED unless reth.enabled - no default for security)
  url: ""
  # -- Use existing secret for L1 RPC URL
  existingSecret: ""
  # -- Key in existing secret
  existingSecretKey: "l1-rpc-url"

# -- Erigon Ethereum Node (recommended internal L1 RPC)
# When enabled, provides an internal Ethereum mainnet node with integrated
# Caplin consensus layer. This eliminates the need for both external RPC
# providers AND a separate consensus client (Lighthouse/Prysm).
erigon:
  # -- Enable Erigon deployment (provides internal L1 RPC with consensus)
  enabled: true

  # -- Number of replicas (1 recommended for blockchain nodes)
  replicaCount: 1

  # -- Image configuration
  image:
    # -- Image registry
    registry: docker.io
    # -- Image repository
    repository: erigontech/erigon
    # -- Image tag
    tag: "v3.3.0"
    # -- Image pull policy
    pullPolicy: IfNotPresent

  # -- Ethereum network (mainnet, sepolia, holesky)
  chain: mainnet

  # -- Prune mode (archive, full, minimal)
  # archive: Full history (~2TB), full: Default (~1TB), minimal: Latest state (~500GB)
  pruneMode: full

  # -- Caplin (integrated consensus layer) configuration
  caplin:
    # -- Enable Caplin (set to false to use external consensus client with --externalcl)
    enabled: true
    # -- Checkpoint sync URL for fast initial sync (optional)
    # Example: https://beaconstate.info/eth/v2/debug/beacon/states/finalized
    checkpointSyncUrl: "https://beaconstate.info/eth/v2/debug/beacon/states/finalized"

  # -- Maximum network peer count (optional, default 100)
  maxPeers: 100

  # -- HTTP RPC port
  httpPort: 8545

  # -- WebSocket RPC port
  wsPort: 8546

  # -- RPC API namespaces to expose
  httpApi: "eth,net,web3,debug,trace,txpool"

  # -- P2P port for execution layer peer discovery
  p2pPort: 30303

  # -- Caplin discovery port (UDP, DISCV5)
  caplinDiscoveryPort: 4000

  # -- Caplin TCP port for consensus P2P
  caplinTcpPort: 4001

  # -- Beacon API port (for validators and monitoring)
  beaconApiPort: 5555

  # -- Enable metrics endpoint
  metricsEnabled: true

  # -- Metrics port
  metricsPort: 6060

  # -- NAT traversal mode (none, any, extip:<IP>, upnp)
  # Use "none" if pod has direct public IP, "extip:<IP>" for known external IP
  nat: "none"

  # -- Custom bootnodes (optional)
  bootnodes: []

  # -- Persistent storage for blockchain data
  persistence:
    # -- Enable persistent storage
    enabled: true
    # -- Storage size (500Gi works for testnet/minimal, increase for mainnet full/archive)
    size: 2Ti
    # -- Storage class (empty string uses cluster default)
    storageClass: ""
    # -- Access mode
    accessMode: ReadWriteOnce
    # -- Annotations for PVC (cloud-specific performance tuning)
    annotations: {}
    # -- Labels for PVC
    labels: {}
    #
    # Cloud-Specific Storage Class Examples for Erigon (High IOPS Required)
    # =====================================================================
    # Erigon Ethereum nodes require high IOPS for optimal sync performance.
    # Recommended: 50,000+ IOPS for production mainnet nodes.
    #
    # See reth.persistence section for cloud-specific storage class examples.
    # The same recommendations apply to Erigon.

  # -- Resource requests and limits (mainnet requirements with Caplin)
  resources:
    requests:
      cpu: "4"
      memory: "16Gi"
    limits:
      cpu: "8"
      memory: "32Gi"

  # -- Pod security context (ignored if openshift.enabled)
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  # -- Container security context (ignored if openshift.enabled)
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    runAsUser: 1000
    capabilities:
      drop:
        - ALL

  # -- Startup probe configuration (allows long initial sync time)
  # Liveness/readiness probes are disabled until startup probe succeeds.
  # Default: 60s period * 2880 failures = 48 hours max startup time
  startupProbe:
    # -- Initial delay before probe starts
    initialDelaySeconds: 30
    # -- Period between probes
    periodSeconds: 60
    # -- Timeout for each probe
    timeoutSeconds: 10
    # -- Number of failures before pod is killed (60s * 2880 = 48 hours)
    failureThreshold: 2880

  # -- Liveness probe configuration (only runs after startup succeeds)
  livenessProbe:
    # -- Initial delay before probe starts
    initialDelaySeconds: 10
    # -- Period between probes
    periodSeconds: 30
    # -- Timeout for each probe
    timeoutSeconds: 10
    # -- Number of failures before pod is restarted
    failureThreshold: 5

  # -- Readiness probe configuration (only runs after startup succeeds)
  readinessProbe:
    # -- Initial delay before probe starts
    initialDelaySeconds: 10
    # -- Period between probes
    periodSeconds: 10
    # -- Timeout for each probe
    timeoutSeconds: 5
    # -- Number of failures before pod is marked unready
    failureThreshold: 3

  # -- Node selector
  nodeSelector: {}

  # -- Tolerations
  tolerations: []

  # -- Affinity rules
  affinity: {}

  # -- Extra arguments for erigon command
  extraArgs: []

# -- External Node (StatefulSet)
externalNode:
  # -- Enable external node deployment
  enabled: true

  # -- Number of replicas (1 recommended for blockchain nodes)
  replicaCount: 1

  # -- Image configuration
  image:
    # -- Image registry
    registry: harbor.sre.ideasoft.io
    # -- Image repository
    repository: adi-chain/external-node
    # -- Image tag (defaults to Chart.appVersion)
    tag: "v0.10.1-b5"
    # -- Image pull policy
    pullPolicy: IfNotPresent

  # -- Update strategy for StatefulSet
  updateStrategy:
    # -- Type of update strategy (RollingUpdate or OnDelete)
    type: RollingUpdate

  # -- Log level (RUST_LOG format)
  logLevel: "info,zksync_os_server=info,zksync_os_sequencer=info,zksync_os_merkle_tree=info,zksync_os_priority_tree=info,zksync_os_server::prover_api=info"

  # -- Persistent storage for blockchain data
  persistence:
    # -- Storage size
    size: 500Gi
    # -- Access mode
    accessMode: ReadWriteOnce
    # -- Storage class (empty string uses cluster default)
    # If defined, storageClassName: <storageClass>
    # If set to "-", storageClassName: "", which disables dynamic provisioning
    # If undefined or empty, uses the default provisioner (gp2 on AWS, standard on GKE/Azure)
    storageClass: ""
    # -- Annotations for PVC (cloud-specific performance tuning)
    annotations: {}
    # -- Labels for PVC
    labels: {}
    #
    # Cloud-Specific Storage Class Examples for External Node
    # ========================================================
    # External node has moderate IOPS requirements compared to Reth.
    #
    # AWS EKS:
    #   storageClass: "gp3"  # Default gp3 is sufficient for most cases
    #
    # GKE:
    #   storageClass: "premium-rwo"  # SSD for good performance
    #
    # Azure AKS:
    #   storageClass: "managed-csi-premium"  # Premium SSD recommended

  # -- Resource requests and limits
  resources:
    requests:
      memory: "4Gi"
      cpu: "1"
    limits:
      memory: "8Gi"
      cpu: "4"

  # -- Pod security context (ignored if openshift.enabled)
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    fsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  # -- Container security context (ignored if openshift.enabled)
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    runAsUser: 1000
    capabilities:
      drop:
        - ALL

  # -- Liveness probe configuration
  # Probes check the RPC port (3050) to verify the node is accepting connections
  livenessProbe:
    # -- Initial delay before probe starts
    initialDelaySeconds: 60
    # -- Period between probes
    periodSeconds: 30
    # -- Timeout for each probe
    timeoutSeconds: 10
    # -- Number of failures before pod is restarted
    failureThreshold: 5

  # -- Readiness probe configuration
  # Probes check the RPC port (3050) to verify the node is accepting connections
  readinessProbe:
    # -- Initial delay before probe starts
    initialDelaySeconds: 30
    # -- Period between probes
    periodSeconds: 10
    # -- Timeout for each probe
    timeoutSeconds: 5
    # -- Number of failures before pod is marked unready
    failureThreshold: 3

  # -- Extra environment variables
  extraEnv: []
  #   - name: CUSTOM_VAR
  #     value: "custom-value"

  # -- Extra volume mounts
  extraVolumeMounts: []

  # -- Extra volumes
  extraVolumes: []

# -- Cloudflared TCP Proxy (Deployment)
cloudflared:
  # -- Enable cloudflared deployment
  enabled: true

  # -- Number of replicas
  replicaCount: 1

  # -- Image configuration
  image:
    # -- Image registry
    registry: docker.io
    # -- Image repository
    repository: cloudflare/cloudflared
    # -- Image tag
    tag: "2025.11.1"
    # -- Image pull policy
    pullPolicy: IfNotPresent

  # -- Replay endpoint hostname
  replayHostname: "replay.adifoundation.ai"

  # -- Listener port
  listenerPort: 3053

  # -- Resource requests and limits
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "128Mi"
      cpu: "100m"

  # -- Pod security context
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 65532
    runAsGroup: 65532
    seccompProfile:
      type: RuntimeDefault

  # -- Container security context
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    runAsNonRoot: true
    capabilities:
      drop:
        - ALL

# -- Proof Sync (Deployment)
proofSync:
  # -- Enable proof-sync deployment
  enabled: true

  # -- Number of replicas
  replicaCount: 1

  # -- Image configuration
  image:
    # -- Image registry
    registry: docker.io
    # -- Image repository
    repository: peterdavehello/azcopy
    # -- Image tag
    tag: "10.27.1"
    # -- Image pull policy
    pullPolicy: IfNotPresent

  # -- Azure Blob Storage URL for proofs
  storageUrl: "https://adimainnet.blob.core.windows.net/proofs"

  # -- Sync interval in seconds
  syncInterval: 60

  # -- Delete destination files not in source
  deleteDestination: "false"

  # -- Resource requests and limits
  resources:
    requests:
      memory: "64Mi"
      cpu: "50m"
    limits:
      memory: "256Mi"
      cpu: "200m"

  # -- Pod security context
  podSecurityContext:
    runAsNonRoot: true
    runAsUser: 1000
    runAsGroup: 1000
    seccompProfile:
      type: RuntimeDefault

  # -- Container security context
  containerSecurityContext:
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: false
    runAsNonRoot: true
    capabilities:
      drop:
        - ALL

# -- Service Account configuration
serviceAccount:
  # -- Create a service account
  create: true
  # -- Service account name (auto-generated if empty)
  name: ""
  # -- Automount service account token (default: false for security)
  automountServiceAccountToken: false
  # -- Annotations for service account
  annotations: {}
  #
  # Cloud Workload Identity Annotations
  # ====================================
  # Enable secure, keyless authentication to cloud services.
  #
  # AWS EKS (IRSA - IAM Roles for Service Accounts):
  # -------------------------------------------------
  # annotations:
  #   eks.amazonaws.com/role-arn: "arn:aws:iam::ACCOUNT_ID:role/adi-stack-role"
  #   # Use STS regional endpoint (recommended for reliability):
  #   eks.amazonaws.com/sts-regional-endpoints: "true"
  #
  # GKE (Workload Identity):
  # ------------------------
  # annotations:
  #   iam.gke.io/gcp-service-account: "adi-stack@PROJECT_ID.iam.gserviceaccount.com"
  #
  # Azure AKS (Workload Identity):
  # ------------------------------
  # annotations:
  #   azure.workload.identity/client-id: "CLIENT_ID"
  #   azure.workload.identity/tenant-id: "TENANT_ID"
  # Note: For Azure, also add to pod labels (via commonLabels):
  #   azure.workload.identity/use: "true"

# -- RBAC configuration
rbac:
  # -- Create RBAC resources
  create: true
  # -- Additional RBAC rules
  rules: []

# -- Service configuration
service:
  # -- Service type
  type: ClusterIP
  # -- Service ports
  ports:
    rpc: 3050
    health: 3071
    replay: 3054
    metrics: 3312
  # -- Service annotations
  annotations: {}
  #
  # Cloud-Specific Load Balancer Annotations
  # =========================================
  # Use type: LoadBalancer with these annotations for external access.
  #
  # AWS EKS (Network Load Balancer):
  # --------------------------------
  # type: LoadBalancer
  # annotations:
  #   service.beta.kubernetes.io/aws-load-balancer-type: "external"
  #   service.beta.kubernetes.io/aws-load-balancer-nlb-target-type: "ip"
  #   service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
  #   # Cross-zone load balancing for high availability:
  #   service.beta.kubernetes.io/aws-load-balancer-attributes: "load_balancing.cross_zone.enabled=true"
  #   # For internal LB (private subnet):
  #   # service.beta.kubernetes.io/aws-load-balancer-scheme: "internal"
  #
  # GKE (Network Endpoint Groups):
  # ------------------------------
  # type: LoadBalancer
  # annotations:
  #   cloud.google.com/neg: '{"ingress": true}'
  #   cloud.google.com/backend-config: '{"default": "adi-backend-config"}'
  #   # Regional external passthrough NLB (GKE 1.32+):
  #   cloud.google.com/l4-rbs: "enabled"
  #
  # Azure AKS (Standard Load Balancer):
  # -----------------------------------
  # type: LoadBalancer
  # annotations:
  #   service.beta.kubernetes.io/azure-load-balancer-internal: "false"
  #   service.beta.kubernetes.io/azure-load-balancer-health-probe-interval: "5"
  #   service.beta.kubernetes.io/azure-load-balancer-health-probe-num-of-probe: "2"
  #   # For internal LB:
  #   # service.beta.kubernetes.io/azure-load-balancer-internal: "true"
  #   # service.beta.kubernetes.io/azure-load-balancer-internal-subnet: "my-subnet"
  #
  # -- Session affinity
  sessionAffinity: None

# -- Ingress configuration
ingress:
  # -- Ingress type: ingress, gateway, route, or auto (detect platform)
  type: auto

  # -- Enable ingress
  enabled: false

  # -- Hostname for ingress
  hostname: ""

  # -- Path for ingress
  path: /
  # -- Path type
  pathType: Prefix

  # -- TLS configuration
  tls:
    # -- Enable TLS
    enabled: true
    # -- TLS secret name (auto-generated if empty with cert-manager)
    secretName: ""

  # -- Kubernetes Ingress specific
  kubernetes:
    # -- Ingress class name (nginx, alb, gce, azure/application-gateway, or empty for cluster default)
    # Set to empty string "" to use cluster default, or omit ingressClassName entirely
    className: ""
    # -- Ingress annotations
    annotations: {}
    # nginx.ingress.kubernetes.io/ssl-redirect: "true"
    # cert-manager.io/cluster-issuer: "letsencrypt-prod"
    #
    # Cloud-Specific Ingress Annotations
    # ===================================
    #
    # AWS ALB Ingress Controller:
    # ---------------------------
    # className: alb
    # annotations:
    #   alb.ingress.kubernetes.io/scheme: "internet-facing"
    #   alb.ingress.kubernetes.io/target-type: "ip"
    #   alb.ingress.kubernetes.io/healthcheck-path: "/health"
    #   alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
    #   alb.ingress.kubernetes.io/ssl-redirect: "443"
    #   # WAF protection:
    #   # alb.ingress.kubernetes.io/wafv2-acl-arn: "arn:aws:wafv2:region:account:..."
    #
    # GKE Ingress (GCE):
    # ------------------
    # className: gce
    # annotations:
    #   kubernetes.io/ingress.global-static-ip-name: "adi-stack-ip"
    #   networking.gke.io/managed-certificates: "adi-stack-cert"
    #   # Cloud Armor (DDoS protection):
    #   # networking.gke.io/v1beta1.FrontendConfig: "adi-frontend-config"
    #
    # Azure Application Gateway:
    # --------------------------
    # className: azure/application-gateway
    # annotations:
    #   appgw.ingress.kubernetes.io/backend-protocol: "http"
    #   appgw.ingress.kubernetes.io/ssl-redirect: "true"
    #   appgw.ingress.kubernetes.io/connection-draining: "true"
    #   appgw.ingress.kubernetes.io/connection-draining-timeout: "30"
    #   # WAF policy:
    #   # appgw.ingress.kubernetes.io/waf-policy-for-path: "/subscriptions/.../wafPolicies/..."

  # -- Gateway API specific
  gateway:
    # -- Gateway class name (e.g., "contour", "istio", "cilium")
    className: ""
    # -- Attach to existing Gateway by name (skips Gateway creation)
    # Use with gatewayNamespace for shared Gateway across namespaces
    gatewayName: ""
    # -- Namespace of existing Gateway (for shared Gateway setup)
    # When set, HTTPRoutes will reference Gateway in this namespace
    gatewayNamespace: ""
    # -- Gateway listener section name
    sectionName: ""
    # -- Create HTTPProxy for advanced routing (Contour only)
    # Enables timeout configuration for JSON-RPC workloads
    useHTTPProxy: false
    # -- Timeout configuration (requires useHTTPProxy: true for Contour)
    timeouts:
      # -- Response timeout (time from request end to response end)
      # Recommended: 30s for JSON-RPC (eth_call, eth_estimateGas can be slow)
      response: "30s"
      # -- Idle timeout (inactivity during request/response)
      # Recommended: 300s (5 minutes) for persistent connections
      idle: "300s"
      # -- Connection idle timeout (keep connection open when idle)
      idleConnection: "1h"
    # -- Retry policy for failed requests (Contour HTTPProxy only)
    retryPolicy:
      # -- Number of retries (0 to disable, recommended for JSON-RPC)
      count: 0
      # -- Timeout per retry attempt
      perTryTimeout: "10s"

  # -- cert-manager integration for automatic TLS certificates
  # Works with both Ingress (via annotations) and Gateway API (via Certificate resource)
  certManager:
    # -- Enable cert-manager Certificate resource for Gateway API
    # For Ingress, use kubernetes.annotations with cert-manager.io/cluster-issuer instead
    enabled: false
    # -- Certificate issuer reference
    issuerRef:
      # -- Name of the ClusterIssuer or Issuer
      name: "letsencrypt-prod"
      # -- Kind: ClusterIssuer or Issuer
      kind: "ClusterIssuer"
    # -- Certificate duration (default: 2160h = 90 days)
    # duration: "2160h"
    # -- Renew before expiry (default: 360h = 15 days)
    # renewBefore: "360h"

  # -- OpenShift Route specific
  route:
    # -- TLS termination type (edge, passthrough, reencrypt)
    termination: edge
    # -- Insecure edge termination policy
    insecureEdgeTerminationPolicy: Redirect
    # -- Wildcard policy
    wildcardPolicy: None
    # -- Route annotations
    annotations: {}

# -- OpenShift specific settings
openshift:
  # -- Enable OpenShift-specific configurations
  enabled: false
  # -- Route settings
  route:
    # -- Create OpenShift Route
    enabled: true

# -- Network policies
networkPolicy:
  # -- Enable network policies
  enabled: false
  # -- Ingress rules
  ingress: []
  #   - from:
  #       - namespaceSelector:
  #           matchLabels:
  #             kubernetes.io/metadata.name: ingress-nginx
  #     ports:
  #       - port: 3050
  #       - port: 3071
  # -- Egress rules
  egress: []
  #   - to:
  #       - ipBlock:
  #           cidr: 0.0.0.0/0
  #     ports:
  #       - port: 443
  #       - port: 8545

# -- Pod Disruption Budget
podDisruptionBudget:
  # -- Enable PDB
  enabled: false
  # -- Minimum available pods
  minAvailable: 1
  # -- Maximum unavailable pods (alternative to minAvailable)
  # maxUnavailable: 0

# -- Metrics and monitoring
metrics:
  # -- ServiceMonitor for Prometheus Operator
  serviceMonitor:
    # -- Enable ServiceMonitor
    enabled: false
    # -- Scrape interval
    interval: 30s
    # -- Scrape timeout
    scrapeTimeout: 10s
    # -- Additional labels for ServiceMonitor
    labels: {}
    # -- Namespace for ServiceMonitor (defaults to release namespace)
    namespace: ""
    # -- Metric relabeling configs
    metricRelabelings: []
    # -- Relabeling configs
    relabelings: []

  # -- PrometheusRule for alerting
  prometheusRule:
    # -- Enable PrometheusRule
    enabled: false
    # -- Additional labels for PrometheusRule
    labels: {}
    # -- Alerting rules
    rules: []

# -- Node scheduling
# -- Node selector
nodeSelector: {}
#
# Cloud-Optimized Node Selection
# ===============================
# For blockchain nodes, use storage-optimized instances with NVMe SSDs.
#
# AWS EKS (Storage-Optimized Instances):
# --------------------------------------
# nodeSelector:
#   node.kubernetes.io/instance-type: "i4i.4xlarge"    # NVMe SSD, high IOPS
#   # Or for cost optimization with good performance:
#   # node.kubernetes.io/instance-type: "r6i.2xlarge"
#   # Or use a node group label:
#   # role: blockchain
#
# GKE (Performance Compute Class):
# --------------------------------
# nodeSelector:
#   cloud.google.com/compute-class: "Performance"
#   cloud.google.com/machine-family: "c3"
#   # For local SSD (highest performance):
#   # cloud.google.com/gke-local-ssd: "true"
#
# Azure AKS (High-Performance Node Pool):
# ---------------------------------------
# nodeSelector:
#   kubernetes.azure.com/agentpool: "highperf"
#   # Or by VM SKU (storage-optimized):
#   # kubernetes.azure.com/vm-sku: "Standard_L8s_v3"

# -- Tolerations
tolerations: []
#
# Toleration Examples for Dedicated Node Pools:
# ==============================================
# tolerations:
# - key: "dedicated"
#   operator: "Equal"
#   value: "blockchain"
#   effect: "NoSchedule"
# - key: "high-performance"
#   operator: "Equal"
#   value: "true"
#   effect: "NoSchedule"

# -- Affinity rules
affinity: {}
#
# Affinity Examples for Storage-Optimized Nodes:
# ===============================================
#
# AWS EKS - Prefer storage-optimized instances:
# affinity:
#   nodeAffinity:
#     preferredDuringSchedulingIgnoredDuringExecution:
#     - weight: 100
#       preference:
#         matchExpressions:
#         - key: node.kubernetes.io/instance-type
#           operator: In
#           values:
#           - i4i.4xlarge
#           - i4i.8xlarge
#           - i3.4xlarge
#           - i3.8xlarge
#
# GKE - Require local SSD nodes:
# affinity:
#   nodeAffinity:
#     requiredDuringSchedulingIgnoredDuringExecution:
#       nodeSelectorTerms:
#       - matchExpressions:
#         - key: cloud.google.com/gke-local-ssd
#           operator: Exists
#
# Anti-affinity to spread across zones:
# affinity:
#   podAntiAffinity:
#     preferredDuringSchedulingIgnoredDuringExecution:
#     - weight: 100
#       podAffinityTerm:
#         labelSelector:
#           matchLabels:
#             app.kubernetes.io/name: adi-stack
#         topologyKey: topology.kubernetes.io/zone

# -- Topology spread constraints
topologySpreadConstraints: []
#   - maxSkew: 1
#     topologyKey: topology.kubernetes.io/zone
#     whenUnsatisfiable: ScheduleAnyway
#     labelSelector:
#       matchLabels:
#         app.kubernetes.io/name: adi-stack

# -- Priority class name
priorityClassName: ""
#
# Priority Class Configuration
# =============================
# For production blockchain nodes, use high-priority scheduling.
#
# Create a PriorityClass resource:
# apiVersion: scheduling.k8s.io/v1
# kind: PriorityClass
# metadata:
#   name: blockchain-critical
# value: 1000000
# globalDefault: false
# description: "Critical priority for blockchain nodes"
#
# Then set:
# priorityClassName: "blockchain-critical"
#
# Built-in classes (available on all clouds):
# - system-cluster-critical (2000000000) - reserved for system components
# - system-node-critical (2000001000) - reserved for node-critical pods

# -- Pod annotations (applied to all pods)
podAnnotations: {}
#
# Cloud-Specific Pod Annotations
# ===============================
#
# All Clouds - Prevent Cluster Autoscaler eviction:
# -------------------------------------------------
# podAnnotations:
#   cluster-autoscaler.kubernetes.io/safe-to-evict: "false"
#
# AWS EKS - Fargate selector annotations:
# ---------------------------------------
# podAnnotations:
#   eks.amazonaws.com/compute-type: "fargate"  # For Fargate scheduling
#
# GKE Autopilot - Resource guarantees:
# ------------------------------------
# podAnnotations:
#   autopilot.gke.io/resource-adjustment: "disabled"
#
# Azure AKS - Workload Identity label (also needs SA annotation):
# ---------------------------------------------------------------
# Use commonLabels instead:
# commonLabels:
#   azure.workload.identity/use: "true"

# -- Termination grace period
terminationGracePeriodSeconds: 30

# -- Common labels for all resources
commonLabels: {}

# -- Common annotations for all resources
commonAnnotations: {}

# -- Extra objects to deploy
extraObjects: []
#   - apiVersion: v1
#     kind: ConfigMap
#     metadata:
#       name: extra-config
#     data:
#       key: value
